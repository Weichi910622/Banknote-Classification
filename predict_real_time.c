#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "NuMicro.h"

#define PLL_CLOCK       50000000

/******************************************************************
 * dataset format setting
 ******************************************************************/

#define train_data_num 120			//Total number of training data
#define test_data_num 24		//Total number of testing data

/******************************************************************
 * Network Configuration - customized per network 
 ******************************************************************/
#define input_length 15				//The number of input
#define HiddenNodes 30 						//The number of neurons in hidden layer
#define target_num 3						//The number of output

volatile uint32_t g_u32AdcIntFlag;

const float LearningRate = 0.01;						//Learning Rate
const float Momentum = 0.9;
const float InitialWeightMax = 0.5;
const float goal_acc = 	0.99;							//Target accuracy

// Create training dataset/output
float train_data_input[train_data_num][input_length] = {
{182,145,398,509,404,891,533,380,849,486,350,771,170,116,342},

{180,143,399,556,444,952,526,379,849,292,199,508,171,118,347},

{182,144,400,461,364,814,548,405,899,218,146,414,168,116,341},

{182,143,396,494,396,870,520,383,856,229,152,429,168,116,341},

{180,143,392,559,476,998,582,413,913,256,170,467,169,116,340},

{184,145,398,413,319,733,469,320,770,265,175,465,170,117,343},

{185,145,401,417,332,752,448,320,749,288,194,501,170,118,345},

{183,143,397,511,411,896,543,395,881,238,159,441,168,115,338},

{192,146,401,467,366,809,519,370,825,234,155,430,170,116,340},

{184,147,399,546,453,962,573,413,907,302,203,522,168,116,340},

{185,146,399,472,316,740,589,467,996,227,152,430,169,119,344},

{182,141,397,419,299,701,511,387,863,340,237,580,172,118,348},

{184,144,398,420,294,696,540,434,937,221,149,421,170,118,344},

{186,143,394,390,268,648,554,450,976,236,161,442,169,118,341},

{191,144,399,360,243,601,555,442,953,264,178,477,171,120,348},

{192,145,400,333,230,575,445,309,731,382,278,648,171,119,346},

{184,144,402,467,318,743,576,455,968,217,149,417,170,118,345},

{188,145,400,448,305,704,592,477,1010,225,154,432,172,118,346},

{187,145,397,433,286,682,559,431,939,243,164,451,172,120,348},

{187,146,399,468,312,729,591,482,1016,206,141,405,169,117,342},

{139,348,395,448,357,751,592,492,978,211,155,389,188,139,348},

{192,161,393,598,477,953,516,384,780,192,145,368,185,137,346},

{137,345,398,603,473,946,548,416,832,192,133,369,185,137,345},

{192,163,397,621,465,941,558,438,881,192,146,370,187,137,347},

{146,364,393,142,352,1078,192,147,367,192,143,353,192,141,348},

{214,163,393,627,489,964,535,405,816,192,145,370,185,137,347},

{192,161,393,605,485,966,375,276,610,192,143,367,185,137,347},

{192,164,398,614,484,960,639,502,960,192,146,374,187,138,348},

{206,165,401,626,473,945,350,253,574,192,144,367,186,137,346},

{192,162,393,608,482,955,544,421,861,192,145,370,186,137,346},

{177,144,396,575,475,989,529,382,859,192,139,401,167,117,339},

{180,145,398,576,491,1019,557,393,880,259,170,466,172,119,348},

{185,146,400,514,432,930,541,388,871,253,169,448,168,116,339},

{184,145,398,538,434,925,552,391,876,234,153,436,168,117,342},

{182,146,397,605,504,1039,560,394,883,192,139,403,169,117,341},

{183,146,401,428,354,794,532,404,890,251,169,466,169,118,346},

{183,145,400,549,445,942,546,385,862,230,152,434,170,118,345},

{183,145,396,562,462,972,557,390,875,270,178,480,168,117,341},

{183,146,400,559,448,960,563,395,884,232,155,436,171,118,346},

{183,146,399,576,448,960,559,384,864,238,160,448,167,116,341},

{180,144,397,447,395,866,489,402,881,296,192,518,167,116,340},

{116,342,395,387,338,771,478,391,858,543,523,1151,169,116,342},

{177,143,399,354,294,698,445,375,833,326,235,572,170,119,345},

{181,146,399,563,507,1040,505,418,913,243,168,459,168,117,340},

{119,349,400,475,418,915,521,436,936,459,370,808,166,117,340},

{179,144,401,424,360,804,448,390,861,226,156,432,168,118,342},

{170,138,391,365,306,719,491,404,882,429,332,776,169,118,345},

{176,144,395,514,446,946,504,423,915,192,141,407,166,117,341},

{174,143,401,573,498,1024,531,444,951,192,142,407,167,117,341},

{179,143,398,455,386,843,466,383,841,311,219,544,168,119,346},

{177,144,400,477,390,850,558,485,1010,210,146,416,166,116,340},

{182,147,400,369,292,683,542,470,990,275,191,496,169,118,345},

{179,142,398,362,284,669,513,432,929,229,157,432,168,117,342},

{182,145,401,396,313,722,538,465,979,222,153,429,166,117,343},

{180,145,400,496,403,874,575,495,1017,203,141,405,168,117,341},

{177,141,394,406,320,741,513,444,945,232,160,443,169,118,344},

{177,143,401,391,309,716,521,437,938,208,145,410,165,116,339},

{183,149,401,405,320,743,536,464,980,279,194,503,169,118,346},

{181,144,393,405,325,744,538,460,972,271,188,491,168,119,344},

{182,141,396,414,320,740,448,373,818,232,158,432,166,117,339},

{192,166,400,560,484,943,549,448,907,192,147,371,185,138,345},

{192,165,396,566,480,936,543,459,905,192,147,375,185,136,348},

{192,166,401,550,456,912,611,540,1041,192,150,383,186,138,348},

{143,363,393,410,371,776,532,466,930,205,153,392,186,137,347},

{145,370,392,576,490,950,648,596,1129,210,154,389,185,137,347},

{192,165,400,541,448,899,440,336,699,192,146,373,187,138,347},

{178,147,400,451,388,836,493,423,911,253,179,477,171,119,345},

{118,341,396,528,447,934,448,377,832,341,246,600,167,118,341},

{180,147,398,453,397,859,466,395,863,290,207,524,169,119,345},

{152,430,399,396,319,745,438,359,802,514,442,941,169,119,347},

{174,145,400,526,454,952,462,385,844,253,175,467,171,121,347},

{179,146,395,493,454,941,446,349,782,244,167,460,168,118,343},

{133,383,395,428,402,874,539,448,957,455,375,827,169,120,347},

{181,148,400,515,446,924,463,389,850,211,147,412,168,119,341},

{170,145,397,307,284,675,453,373,807,435,347,749,167,119,339},

{180,148,400,506,448,956,464,362,798,366,263,611,169,118,344},

{177,145,395,527,474,982,459,372,835,238,167,453,172,120,348},

{180,146,399,402,338,758,400,319,739,225,157,430,172,119,339},

{180,146,398,482,416,891,411,320,753,229,159,433,167,118,342},

{179,144,393,540,509,1039,461,369,818,254,178,476,167,120,343},

{178,145,402,448,424,905,415,365,823,248,177,465,167,118,341},

{178,147,401,438,403,866,421,375,839,242,172,461,167,118,339},

{176,145,400,436,401,865,415,366,821,264,178,488,167,119,345},

{176,144,400,437,398,861,419,368,823,270,195,501,168,120,347},

{175,145,401,448,421,897,421,376,832,214,151,421,165,117,338},

{173,143,400,466,428,913,433,387,861,210,147,415,165,116,340},

{174,145,398,481,439,928,427,380,851,243,176,466,169,120,346},

{174,144,395,436,398,860,424,374,832,225,160,436,166,118,342},

{176,145,400,425,388,847,419,370,834,260,178,484,169,119,347},

{175,144,395,496,448,958,429,372,832,239,166,461,166,117,340},

{176,145,401,379,320,740,448,428,923,217,153,426,165,117,339},

{175,144,401,302,253,617,431,401,875,269,192,492,167,119,344},

{174,144,400,317,271,646,387,347,790,353,269,627,168,119,345},

{175,144,397,320,277,658,374,336,773,301,217,527,166,118,342},

{174,144,399,415,365,805,426,386,861,375,293,662,168,118,347},

{175,143,397,308,258,628,448,428,918,227,161,437,165,117,341},

{178,143,401,291,243,598,402,373,831,314,229,555,169,120,347},

{173,140,393,365,307,704,442,412,897,251,177,469,166,119,347},

{174,142,394,339,283,672,412,381,849,265,186,485,166,117,342},

{176,144,397,354,299,697,398,358,809,317,241,582,165,117,340},

{192,163,395,569,512,1002,611,576,1109,192,149,379,184,137,348},

{192,165,401,537,482,952,483,422,847,192,147,377,184,137,348},

{192,165,400,481,427,868,440,381,778,191,145,369,184,132,345},

{192,163,397,530,476,946,413,348,723,191,145,370,183,137,346},

{192,164,399,540,482,954,546,504,996,205,155,395,186,138,344},

{192,165,398,556,500,984,517,453,893,192,146,373,185,137,347},

{179,147,400,500,441,936,521,494,1036,192,141,405,165,116,338},

{177,145,397,448,396,865,448,404,894,240,175,463,165,117,339},

{176,145,398,440,383,842,497,465,984,214,153,425,167,118,344},

{178,147,397,475,425,910,448,408,899,266,193,499,165,117,340},

{177,148,401,445,405,871,420,388,855,233,169,449,166,118,341},

{177,148,401,448,404,865,448,408,884,214,152,420,167,117,340},

{177,148,401,436,395,852,434,395,861,228,160,431,168,119,342},

{177,146,397,465,427,904,424,383,832,213,152,417,166,118,340},

{176,147,401,476,431,912,421,381,832,247,174,448,168,118,345},

{175,147,399,503,456,950,460,416,896,188,140,396,166,118,340},

{174,147,401,496,446,944,477,432,935,189,141,399,167,118,340},

{177,145,401,414,372,819,433,393,868,239,166,455,168,120,345},

{174,143,393,465,429,913,415,371,834,275,203,508,169,120,348},

{176,145,401,399,355,786,401,362,817,308,229,552,170,121,348}
};
/*

*/
int train_data_output[train_data_num][target_num]  = {
{1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0},
{1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0},
{1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0},
{1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0},
{0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0},
{0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0},
{0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0},
{0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0},
{0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1},
{0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1},
{0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1},
{0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}
};
	

float test_data_input[test_data_num][input_length] = {
{185,146,400,531,425,924,556,396,886,237,160,444,168,117,340},

{182,144,397,555,448,960,557,391,878,250,165,448,171,117,346},

{186,144,392,440,298,704,590,471,1009,247,167,457,171,118,346},

{185,144,400,506,344,788,600,478,1011,203,139,403,170,118,344},

{192,163,398,599,484,960,457,349,730,192,144,370,187,137,347},

{192,162,395,622,495,982,378,269,607,192,143,366,186,136,347},

{180,142,393,543,436,932,546,390,875,249,165,456,172,119,348},

{227,183,401,340,251,557,354,265,573,201,165,409,175,148,348},

{179,144,395,530,448,952,498,411,899,222,162,442,167,118,341},

{179,144,396,538,479,988,503,418,913,221,154,431,166,117,341},

{180,143,401,437,349,780,549,480,1001,210,146,414,167,117,342},

{180,145,401,441,359,800,542,466,979,257,177,478,170,120,348},

{180,147,401,496,418,887,521,454,960,248,177,471,168,118,345},

{180,147,398,491,425,903,510,442,944,276,193,498,170,119,347},

{179,145,398,463,436,939,560,471,978,453,365,805,171,120,348},

{178,146,401,468,408,870,439,363,814,248,177,466,170,120,348},

{176,146,401,479,443,943,432,380,849,258,179,482,168,119,348},

{172,143,400,269,257,642,381,338,769,360,326,693,165,117,339},

{173,141,396,320,271,650,438,403,878,231,162,432,164,117,341},

{174,144,400,381,326,749,475,440,942,236,168,451,166,117,344},

{174,143,393,475,415,892,472,430,928,206,147,415,165,117,341},

{178,147,401,495,438,934,474,430,939,242,179,475,166,118,341},

{172,147,401,448,403,875,409,371,830,292,218,534,169,121,348},

{174,144,394,483,429,914,488,434,927,188,137,394,165,116,340}
};

int test_data_output[test_data_num][target_num] = {
{1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0}, {1, 0, 0},
{0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, {0, 1, 0}, 
{0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}
};

/******************************************************************
 * End Network Configuration
 ******************************************************************/
float HiddenWeights[input_length+1][HiddenNodes] = {
{-0.404682,-0.412675,0.334253,0.129125,-0.273142,0.360770,0.041351,0.319826,-0.012092,-0.602762,-0.018281,0.375928,-0.612734,-0.625547,-0.008799,0.018619,0.137505,-0.074899,0.237813,-0.412560,-0.088321,-0.356850,-0.156932,0.032515,0.450844,0.096343,0.971979,0.017352,-0.253237,-0.366022},
{-0.136581,-0.578729,-0.495638,0.255264,-0.283970,-0.212072,0.364939,0.129022,0.035038,0.123733,0.643201,-0.094675,-0.438702,0.323352,0.418524,0.970404,0.017703,0.197317,-0.261265,-0.111425,-0.030239,0.701796,0.225831,0.681232,-0.761015,0.254436,0.333467,-0.523367,-0.214791,0.392423},
{0.136444,0.478936,0.907188,0.264590,-0.268615,-0.311035,-0.285321,0.124426,0.274843,0.067825,-0.016711,0.363336,-0.355695,0.029806,0.049773,0.057505,0.535926,0.233263,-0.310164,-0.207148,0.346959,-0.079131,-0.103613,0.447284,-0.013570,-0.205307,-0.037740,0.046269,0.049932,-0.083503},
{0.193380,-0.936578,0.266743,0.869236,-1.131100,0.516082,0.690279,0.073716,0.091629,-0.775219,-0.715611,-0.779121,-0.125509,-1.006795,0.406481,0.154550,0.260000,0.373242,-0.451937,0.411451,-0.354452,0.435470,1.364839,0.147872,-0.596022,-0.296920,0.863576,-0.183101,-1.031569,-1.443038},
{-0.675429,0.780183,-0.072185,-0.117606,-0.116556,-0.052803,-1.252146,-0.327791,0.131250,0.400116,-0.104607,0.910800,0.043024,0.246760,-1.236300,0.110062,0.250573,-0.587272,0.142093,-0.297273,0.654529,-0.226610,-0.554917,-0.226026,0.058959,-0.118487,-0.844879,-0.666893,0.215167,0.369747},
{0.045808,0.251036,-0.098463,-0.520504,-0.150831,-0.349650,0.232095,0.315540,0.565662,0.236962,-0.455062,0.089741,0.036281,0.465328,-0.105069,-0.194400,-0.438657,0.048235,-0.140891,0.358639,0.240117,-0.013022,-0.774260,-0.310081,0.108522,-0.056178,0.311994,0.081485,0.838337,0.795662},
{1.051704,-1.570168,0.130425,1.022019,-1.004827,1.063065,2.511110,-0.768420,0.298076,-1.300793,0.223962,-1.147707,-1.247568,-0.934253,0.397995,1.187515,-0.009779,1.523953,-0.401121,0.376910,-0.756585,1.437173,3.080966,0.393728,-0.968960,0.248850,1.358412,0.083612,-1.863284,-3.137086},
{-0.192789,1.289285,0.225815,-0.385100,-0.127644,0.109643,-1.573019,0.526282,0.404719,0.163348,0.748906,1.369765,0.350982,0.800908,-1.036833,-0.929260,0.462625,0.112937,0.981071,-0.395425,0.911411,-0.826838,-1.105168,-0.073230,0.420182,-0.278641,-0.845125,-0.755127,0.912956,1.067915},
{-0.049957,0.053081,-0.415527,0.223835,-0.630730,0.128532,-0.772341,0.376488,0.005414,0.726666,-0.425887,0.189976,0.212815,-0.160244,-0.463165,-0.360034,0.303352,0.083412,0.250539,-0.641749,0.101636,-0.714340,-0.951557,-0.481347,0.723914,0.389926,0.097548,-0.348369,0.543844,1.097443},
{0.106863,-0.034245,0.414308,0.004942,0.229873,-0.049653,0.381042,-0.085320,0.076027,0.057683,0.033811,-0.289461,-0.426844,0.071374,-0.721760,0.504366,0.198879,-0.134244,0.030438,0.355898,0.355276,0.475303,0.706929,0.027682,-0.123530,0.512928,0.504255,-0.173349,-0.522777,-0.687125},
{0.164571,0.100968,0.371241,-0.274481,-0.054198,-0.163321,-0.287353,-0.127542,0.234354,0.122527,-0.011885,0.703311,-0.128980,-0.140262,-0.573541,-0.558201,0.021318,0.156881,-0.175486,0.356109,0.344705,-0.187129,-0.293339,-0.345437,0.753304,0.248609,-0.461084,0.347401,0.363716,0.267769},
{-0.510867,0.368755,-0.224960,0.066886,-0.030697,-0.011345,-0.415984,-0.064272,0.368194,-0.279694,-0.350288,-0.027440,-0.105263,-0.301482,-0.302285,0.142323,-0.079361,0.671235,-0.270227,0.422836,-0.311613,-0.420339,-0.327247,0.024281,0.110209,-0.057877,0.206555,-0.125792,0.127450,0.186498},
{-0.078802,-0.239383,0.671919,-0.105495,-0.615813,0.209349,0.291956,-0.381007,-0.175040,0.367827,0.192682,-0.138529,0.150301,0.180145,-0.300019,-0.103692,-0.478827,0.150426,-0.098108,-0.261105,-0.562482,0.451358,0.571455,0.549910,-0.327340,0.248041,0.435842,-0.062688,-0.313502,-0.059273},
{-0.314546,0.733275,0.844278,-0.495483,0.332514,-0.215318,-0.423553,-0.349483,-0.598791,0.228232,-0.404965,0.377897,0.362880,0.300945,-0.470331,-0.022681,-0.416612,-0.537305,0.278253,0.035022,0.279089,-0.942571,-0.967942,-0.051491,0.568514,0.405010,-0.713828,-0.559282,0.351174,1.071158},
{0.214417,-0.453446,0.934611,0.134249,0.761097,-0.059543,0.276104,-0.005030,-0.765238,0.024726,0.143978,-0.491664,0.229848,0.023074,-0.463791,-0.066656,0.086512,0.014006,0.203532,0.565441,0.071167,0.070201,-0.053433,-0.036159,-0.074408,0.395696,-0.187855,-0.468367,0.025575,-0.149797},
{-0.133024,1.188562,-0.474151,-0.344042,0.672351,0.070707,-1.303564,-0.026927,0.622935,-0.164092,-0.508651,0.529829,-0.450310,0.661409,0.075879,0.282495,0.301896,0.114082,0.071260,-0.302024,-0.211344,0.474616,1.747967,0.275147,-0.254316,0.408658,-1.324780,0.335875,0.668697,-1.404073}
};

float OutputWeights[HiddenNodes+1][target_num] ={
{0.756533,-0.122581,-0.959655},
{-2.008184,1.569481,0.529648},
{0.004684,-1.384323,0.054870},
{0.954788,-0.561430,-1.071567},
{-0.564582,1.405901,0.160127},
{0.772848,0.049588,-0.802952},
{2.044430,-2.249325,-2.220514},
{-0.441477,-0.314745,0.580965},
{-0.896654,0.105403,-0.711105},
{-0.853147,-0.432536,0.933805},
{-0.543880,1.011571,-0.661273},
{-1.627643,0.900795,1.240199},
{-0.774529,-0.883809,0.352541},
{-0.947971,0.492803,0.991597},
{0.982277,-1.513625,-0.988962},
{0.760827,0.283044,-1.876451},
{0.032244,-0.576137,0.101291},
{0.506996,0.111375,-1.735784},
{-0.369243,0.248651,0.931471},
{0.743967,0.030434,-0.679169},
{-1.391417,-0.206180,0.502015},
{1.260891,0.451410,-2.189249},
{0.688044,2.954776,-1.962385},
{0.444330,0.386876,-0.799140},
{-1.351414,-1.085562,1.178279},
{0.190331,-0.431551,-0.331316},
{1.167365,-1.774060,-1.050977},
{-0.027957,-0.969389,-0.673793},
{-2.075850,0.678810,1.580228},
{-1.144985,-2.760261,2.163166},
{0.276788,-0.808655,0.020852}
};

volatile int ReportEvery10;
volatile int RandomizedIndex[train_data_num];
volatile long  TrainingCycle;
volatile float Rando;
volatile float Error;
volatile float Accum;

volatile float data_mean[15] = {177.67, 165.69, 398.02, 467.30, 393.86, 850.96, 488.77, 403.29, 871.57, 253.68, 183.04, 473.58, 171.34, 121.44, 343.58};
volatile float data_std[15] = {15.05, 60.49, 2.71, 85.36, 73.38, 116.23, 69.23, 57.58, 96.18, 70.45, 62.26, 118.90, 7.07, 7.60, 3.10};


volatile float Hidden[HiddenNodes];
volatile float Output[target_num];
//float HiddenWeights[input_length+1][HiddenNodes];
//float OutputWeights[HiddenNodes+1][target_num];
volatile float HiddenDelta[HiddenNodes];
volatile float OutputDelta[target_num];
volatile float ChangeHiddenWeights[input_length+1][HiddenNodes];
volatile float ChangeOutputWeights[HiddenNodes+1][target_num];

volatile int target_value;
volatile int out_value;
volatile int max;


/*---------------------------------------------------------------------------------------------------------*/
/* Define Function Prototypes                                                                              */
/*---------------------------------------------------------------------------------------------------------*/
void SYS_Init(void);
void UART0_Init(void);
void AdcSingleCycleScanModeTest(void);


void SYS_Init(void)
{
    /*---------------------------------------------------------------------------------------------------------*/
    /* Init System Clock                                                                                       */
    /*---------------------------------------------------------------------------------------------------------*/

    /* Unlock protected registers */
    SYS_UnlockReg();
    /* Enable HIRC */
    CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
    /* Waiting for HIRC clock ready */
    CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
    /* Switch HCLK clock source to HIRC */
    CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
    /* Set both PCLK0 and PCLK1 as HCLK/2 */
    CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
    /* Switch UART0 clock source to HIRC */
    CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));
    /* Enable UART peripheral clock */
    CLK_EnableModuleClock(UART0_MODULE);
    /* Enable ADC module clock */
    CLK_EnableModuleClock(ADC_MODULE);
    /* ADC clock source is PCLK1, set divider to 1 */
    CLK_SetModuleClock(ADC_MODULE, CLK_CLKSEL2_ADCSEL_PCLK1, CLK_CLKDIV0_ADC(1));

    /* Update System Core Clock */
    /* User can use SystemCoreClockUpdate() to calculate PllClock, SystemCoreClock and CycylesPerUs automatically. */
    SystemCoreClockUpdate();
		
		
    /*---------------------------------------------------------------------------------------------------------*/
    /* Init I/O Multi-function                                                                                 */
    /*---------------------------------------------------------------------------------------------------------*/

    /* Set GPB multi-function pins for UART0 RXD and TXD */
    SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk)) |
                    (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);

    /* Set PB.0,1,4 to input mode */
    GPIO_SetMode(PB, BIT0|BIT1|BIT4, GPIO_MODE_INPUT);
    /* Configure the PB.0,1,4 ADC analog input pins.  */
    SYS->GPB_MFPL = (SYS->GPB_MFPL & ~(SYS_GPB_MFPL_PB0MFP_Msk | SYS_GPB_MFPL_PB1MFP_Msk | SYS_GPB_MFPL_PB4MFP_Msk)) |
                    (SYS_GPB_MFPL_PB0MFP_ADC0_CH0 | SYS_GPB_MFPL_PB1MFP_ADC0_CH1 | SYS_GPB_MFPL_PB4MFP_ADC0_CH4);
    /* Disable the PB.0,1,4 digital input path to avoid the leakage current. */
    GPIO_DISABLE_DIGITAL_PATH(PB, BIT0|BIT1|BIT4);
		

}

/*---------------------------------------------------------------------------------------------------------*/
/* Init UART                                                                                               */
/*---------------------------------------------------------------------------------------------------------*/
void UART0_Init()
{
    /* Reset IP */
    SYS_ResetModule(UART0_RST);

    /* Configure UART0 and set UART0 Baudrate */
    UART_Open(UART0, 115200);
}

void scale_data()
{
		float sum[15] = {0};
		int i, j;
		
		// Compute Data Mean
		for(i = 0; i < train_data_num; i++){
			for(j = 0; j < input_length; j++){
				sum[j] += train_data_input[i][j];
				CLK_SysTickDelay(1000);
			}
		}
		for(j = 0; j < input_length ; j++){
			data_mean[j] = sum[j] / train_data_num;
			printf("MEAN: %.2f\n", data_mean[j]);
			sum[j] = 0.0;
			CLK_SysTickDelay(1000);
		}
		
		// Compute Data STD
		for(i = 0; i < train_data_num; i++){
			for(j = 0; j < input_length ; j++){
				sum[j] += pow(train_data_input[i][j] - data_mean[j], 2);
				CLK_SysTickDelay(5000);
			}
		}
		for(j = 0; j < input_length; j++){
			data_std[j] = sqrt(sum[j]/train_data_num);
			printf("STD: %.2f\n", data_std[j]);
			sum[j] = 0.0;
			CLK_SysTickDelay(5000);
		}
}

void normalize(float *data)
{
		int i;
	
		for(i = 0; i < input_length; i++){
			data[i] = (data[i] - data_mean[i]) / data_std[i];
			CLK_SysTickDelay(5000);
		}
}

int train_preprocess()
{
    int i,j;
    
    for(i = 0 ; i < train_data_num ; i++)
    {
        normalize(train_data_input[i]);
				CLK_SysTickDelay(5000);
				for(j = 0; j < input_length; j++){
					printf("%f ",train_data_input[i][j]);
				}
        printf("\n\n");
    }
		
    return 0;
}

int test_preprocess()
{
    int i;

    for(i = 0 ; i < test_data_num ; i++)
    {
        normalize(test_data_input[i]);
    }
		
    return 0;
}

int data_setup()
{
    int i;
		//int j;
		int p, ret;
		unsigned int seed = 1;
	
		seed *= 1000;
		printf("\nRandom seed: %d\n", seed);
    srand(seed);

    ReportEvery10 = 1;
    for( p = 0 ; p < train_data_num ; p++ ) 
    {    
        RandomizedIndex[p] = p ;
    }
		
		//scale_data();
    ret = train_preprocess();
    ret |= test_preprocess();
    if(ret) //Error Check
        return 1;

    return 0;
}

void run_train_data()
{
    int i, j, p;
    int correct=0;
    float accuracy = 0;
    printf("Train result:\n");
    for( p = 0 ; p < train_data_num ; p++ )
    { 
        max = 0;
        for (i = 1; i < target_num; i++) 
        {
            if (train_data_output[p][i] > train_data_output[p][max]) {
                max = i;
            }
        }
        target_value = max;
        
    /******************************************************************
    * Compute hidden layer activations
    ******************************************************************/

        for( i = 0 ; i < HiddenNodes ; i++ ) {    
            Accum = HiddenWeights[input_length][i] ;
            for( j = 0 ; j < input_length ; j++ ) {
                Accum += train_data_input[p][j] * HiddenWeights[j][i] ;
            }
            Hidden[i] = 1.0/(1.0 + exp(-Accum)) ;
        }

    /******************************************************************
    * Compute output layer activations and calculate errors
    ******************************************************************/

        for( i = 0 ; i < target_num ; i++ ) {    
            Accum = OutputWeights[HiddenNodes][i] ;
            for( j = 0 ; j < HiddenNodes ; j++ ) {
                Accum += Hidden[j] * OutputWeights[j][i] ;
            }
            Output[i] = 1.0/(1.0 + exp(-Accum)) ; 
        }
        
        max = 0;
        for (i = 1; i < target_num; i++) 
        {
            if (Output[i] > Output[max]) {
                max = i;
            }
        }
        out_value = max;

        if(out_value!=target_value)
            printf("Error --> Training Pattern: %d,Target : %d, Output : %d\n", p, target_value, out_value);
        else
            correct++;
        }
        // Calculate accuracy
        accuracy = (float)correct / train_data_num;
        printf ("Accuracy = %.2f /100 \n",accuracy*100);
}

void run_test_data()
{
    int i, j, p;
    int correct=0;
    float accuracy = 0;
    printf("Test result:\n");
    for( p = 0 ; p < test_data_num ; p++ )
    { 
        max = 0;
        for (i = 1; i < target_num; i++) 
        {
            if (test_data_output[p][i] > test_data_output[p][max]) {
                max = i;
            }
        }
        target_value = max;
        
    /******************************************************************
    * Compute hidden layer activations
    ******************************************************************/

        for( i = 0 ; i < HiddenNodes ; i++ ) {    
            Accum = HiddenWeights[input_length][i] ;
            for( j = 0 ; j < input_length ; j++ ) {
                Accum += test_data_input[p][j] * HiddenWeights[j][i] ;
            }
            Hidden[i] = 1.0/(1.0 + exp(-Accum)) ;
        }

    /******************************************************************
    * Compute output layer activations and calculate errors
    ******************************************************************/

        for( i = 0 ; i < target_num ; i++ ) {    
            Accum = OutputWeights[HiddenNodes][i] ;
            for( j = 0 ; j < HiddenNodes ; j++ ) {
                Accum += Hidden[j] * OutputWeights[j][i] ;
            }
            Output[i] = 1.0/(1.0 + exp(-Accum)) ; 
        }
        max = 0;
        for (i = 1; i < target_num; i++) 
        {
            if (Output[i] > Output[max]) {
                max = i;
            }
        }
        out_value = max;

        if(out_value!=target_value)
            printf("Error --> Training Pattern: %d,Target : %d, Output : %d\n", p, target_value, out_value);
        else
            correct++;
        }
        // Calculate accuracy
        accuracy = (float)correct / test_data_num;
        printf ("Accuracy = %.2f /100 \n",accuracy*100);
}

float Get_Train_Accuracy()
{
    int i, j, p;
    int correct = 0;
		float accuracy = 0;
    for (p = 0; p < train_data_num; p++)
    {
/******************************************************************
* Compute hidden layer activations
******************************************************************/

        for( i = 0 ; i < HiddenNodes ; i++ ) {    
            Accum = HiddenWeights[input_length][i] ;
            for( j = 0 ; j < input_length ; j++ ) {
                Accum += train_data_input[p][j] * HiddenWeights[j][i] ;
            }
            Hidden[i] = 1.0/(1.0 + exp(-Accum)) ;
        }

/******************************************************************
* Compute output layer activations
******************************************************************/

        for( i = 0 ; i < target_num ; i++ ) {    
            Accum = OutputWeights[HiddenNodes][i] ;
            for( j = 0 ; j < HiddenNodes ; j++ ) {
                Accum += Hidden[j] * OutputWeights[j][i] ;
            }
            Output[i] = 1.0/(1.0 + exp(-Accum)) ; 
        }
        //get target value
        max = 0;
        for (i = 1; i < target_num; i++) 
        {
            if (train_data_output[p][i] > train_data_output[p][max]) {
                max = i;
            }
        }
        target_value = max;
        //get output value
        max = 0;
        for (i = 1; i < target_num; i++) 
        {
            if (Output[i] > Output[max]) {
                max = i;
            }
        }
        out_value = max;
        //compare output and target
        if (out_value==target_value)
        {
            correct++;
        }
    }

    // Calculate accuracy
    accuracy = (float)correct / train_data_num;
    return accuracy;
}

void load_weight()
{
    int i,j;
    printf("\n=======Hidden Weight=======\n");
    printf("{");
    for(i = 0; i <= input_length ; i++)
    {
        printf("{");
        for (j = 0; j < HiddenNodes; j++)
        {
            if(j!=HiddenNodes-1){
                printf("%f,", HiddenWeights[i][j]);
            }else{
                printf("%f", HiddenWeights[i][j]);
            }
        }
        if(i!=input_length){
            printf("},\n");
        }else {
            printf("}");
        }
    }
    printf("}\n");

    printf("\n=======Output Weight=======\n");

    for(i = 0; i <= HiddenNodes ; i++)
    {
        printf("{");
        for (j = 0; j < target_num; j++)
        {
            if(j!=target_num-1){
                printf("%f,", OutputWeights[i][j]);
            }else{
                printf("%f", OutputWeights[i][j]);
            }
        }
        if(i!=HiddenNodes){
            printf("},\n");
        }else {
            printf("}");
        }
    }
    printf("}\n");
}

void interpolate(int *input, int input_size, int *output, int output_size){
	int i,j,idx;
	float pos, frac;
	for (i = 0; i < output_size; i++) {
        pos = (float)i / (output_size - 1) * (input_size - 1);
        idx = (int)pos;
        frac = pos - idx;

        if (idx + 1 < input_size) {
            output[i] = input[idx] * (1.0f - frac) + input[idx + 1] * frac;
        } else {
            output[i] = input[idx];
        }
    }
}
void ADC_IRQHandler(void)
{
    g_u32AdcIntFlag = 1;
    ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT); /* Clear the A/D interrupt flag */
}

void AdcSingleCycleScanModeTest()
{
		int i, j;
    uint32_t u32ChannelCount;
		char output_string[10] = {NULL};
		int32_t  R_value[20], G_value[20], B_value[20];
		int index = 0;
		int back_R, back_G, back_B;
		int change = 0;
		int newR[5], newG[5], newB[5];
		float data[15];
		int is_data_input = 0;
		
		
    printf("\n");	
		printf("[Phase 3] Start Prediction ...\n\n");
		PC4=1;
		
		/* Enable ADC converter */
		ADC_POWER_ON(ADC);
		/* Set input mode as single-end, Single mode, and select channel 0,1,4 */
		ADC_Open(ADC, ADC_ADCR_DIFFEN_SINGLE_END, ADC_ADCR_ADMD_SINGLE_CYCLE, 0x13);

		/* Clear the A/D interrupt flag for safe */
		ADC_CLR_INT_FLAG(ADC, ADC_ADF_INT);
		/* Enable the sample module interrupt */
		ADC_ENABLE_INT(ADC, ADC_ADF_INT);
		NVIC_EnableIRQ(ADC_IRQn);
		
		
		g_u32AdcIntFlag = 0;
		ADC_START_CONV(ADC);
	
		/* Wait ADC interrupt */
		while(g_u32AdcIntFlag == 0);

		/* Disable the sample module interrupt */
		ADC_DISABLE_INT(ADC, ADC_ADF_INT);

		back_R = ADC_GET_CONVERSION_DATA(ADC, 1); //R
		back_G = ADC_GET_CONVERSION_DATA(ADC, 0); //G
		back_B = ADC_GET_CONVERSION_DATA(ADC, 4); //B
		printf("{%d, %d, %d}\n", back_R, back_G, back_B);


    while(1)
    {
        change = 0;
				PC4 = 1;
				/* Enable the sample module interrupt */
				ADC_ENABLE_INT(ADC, ADC_ADF_INT);
				NVIC_EnableIRQ(ADC_IRQn);
			
				/* Reset the ADC interrupt indicator and trigger sample module 0 to start A/D conversion */
				g_u32AdcIntFlag = 0;
				ADC_START_CONV(ADC);
			
				/* Wait ADC interrupt */
				while(g_u32AdcIntFlag == 0);
		
				/* Disable the sample module interrupt */
				ADC_DISABLE_INT(ADC, ADC_ADF_INT);
			
				G_value[0] = ADC_GET_CONVERSION_DATA(ADC, 0); //G
				R_value[0] = ADC_GET_CONVERSION_DATA(ADC, 1); //R
				B_value[0] = ADC_GET_CONVERSION_DATA(ADC, 4); //B
				
				if(abs(R_value[0]-back_R)>100 || abs(G_value[0]-back_G)>100 || abs(B_value[0]-back_B)>100){
						change = 1;
						//printf("500\n");
						index = 0;
				}
				
				while(change){
						/* Enable the sample module interrupt */
						ADC_ENABLE_INT(ADC, ADC_ADF_INT);
						NVIC_EnableIRQ(ADC_IRQn);

						/* Reset the ADC interrupt indicator and trigger sample module 0 to start A/D conversion */
						g_u32AdcIntFlag = 0;
						ADC_START_CONV(ADC);
						/* Wait ADC interrupt */
						while(g_u32AdcIntFlag == 0);
						/* Disable the sample module interrupt */
						ADC_DISABLE_INT(ADC, ADC_ADF_INT);
				

						/* Get the conversion result of ADC channels */
						R_value[index] = ADC_GET_CONVERSION_DATA(ADC, 1); //R
						G_value[index] = ADC_GET_CONVERSION_DATA(ADC, 0); //G
						B_value[index] = ADC_GET_CONVERSION_DATA(ADC, 4); //B
						//printf("%d ",index);
						// ori_RGB_ADC
						//printf("{%d, %d, %d}", R_value[index], G_value[index], B_value[index]);


						CLK_SysTickDelay(40000);
						
						if(abs(R_value[index]-back_R)<50 && abs(G_value[index]-back_G)<50 && abs(B_value[index]-back_B)<50){
								change = 0;
								is_data_input = 1;
						}
						
						index++;
				}
				
				
				if(is_data_input){
						//printf("%d\n",index);
						//printf("%d\n",R_value[0]);
						interpolate(R_value, index, newR, 5);
						interpolate(G_value, index, newG, 5);
						interpolate(B_value, index, newB, 5);
						
						for(i = 0; i < 5; i++){
							data[i*3] = newR[i];
							data[i*3+1] = newG[i];
							data[i*3+2] = newB[i];
						}
						
						//interpolated 
						printf("{");
						for (i = 0; i < input_length; i++){
								if(i == input_length-1){
									printf("%d", (int)data[i]);
									break;
								}
								printf("%d,", (int)data[i]);
						}	
						printf("}\n");


						normalize(data);
						
						
						//normalize
//						for (i = 0; i < input_length; i++){
//								printf("%.3f ", data[i]);
//						}
//						printf("\n");
								

						// Compute hidden layer activations
						for( i = 0 ; i < HiddenNodes ; i++ ) {    
								Accum = HiddenWeights[input_length][i] ;
								for( j = 0 ; j < input_length ; j++ ) {
										Accum += data[j] * HiddenWeights[j][i] ;
								}
								Hidden[i] = 1.0/(1.0 + exp(-Accum)) ;
						}

						// Compute output layer activations
						for( i = 0 ; i < target_num ; i++ ) {    
								Accum = OutputWeights[HiddenNodes][i] ;
								for( j = 0 ; j < HiddenNodes ; j++ ) {
										Accum += Hidden[j] * OutputWeights[j][i] ;
								}
								Output[i] = 1.0/(1.0 + exp(-Accum)) ; 
						}
						
								
						max = 0;
						for (i = 1; i < target_num; i++) 
						{
								//printf("%f ", Output[i]);
								CLK_SysTickDelay(50000);
								if (Output[i] > Output[max]) {
										max = i;
								}
						}
						out_value = max;
						
						switch(out_value){
								case 0:
										strcpy(output_string, "100");
										break;
								case 1:
										strcpy(output_string, "500");	
										break;
								case 2:
										strcpy(output_string, "1000");	
										break;
						}
						
						printf("\rPrediction output: %-8s", output_string);
						
						//¾÷²v­È
						for (i =0; i < target_num; i++) 
						{
								printf("%f ", Output[i]);
						}
						
						printf("\n");
						
						is_data_input = 0;
				}
    }
}

/*---------------------------------------------------------------------------------------------------------*/
/* MAIN function                                                                                           */
/*---------------------------------------------------------------------------------------------------------*/

int main(void)
{
		int i, j, p, q, r;
    float accuracy=0;

    /* Unlock protected registers */
    SYS_UnlockReg();

    /* Init System, IP clock and multi-function I/O */
    SYS_Init();

    /* Lock protected registers */
    SYS_LockReg();

    /* Init UART0 for printf */
    UART0_Init();
	
	  GPIO_SetMode(PC, BIT4, GPIO_MODE_OUTPUT);
	  PC4=0;
	
		printf("\n+-----------------------------------------------------------------------+\n");
    printf("|                        LAB8 - Machine Learning                        |\n");
    printf("+-----------------------------------------------------------------------+\n");
		printf("System clock rate: %d Hz\n", SystemCoreClock);

    printf("\n[Phase 1] Initialize DataSet ...");
	  /* Data Init (Input / Output Preprocess) */
		if(data_setup()){
        printf("[Error] Datasets Setup Error\n");
        return 0;
    }else
				printf("Done!\n\n");
		
    run_train_data();
    printf ("Training Set Solved!\n");
    printf ("--------\n"); 
    printf ("Testing Start!\n ");
    run_test_data();
    printf ("--------\n"); 
    ReportEvery10 = 1;
    load_weight();
		
		printf("\nModel Training Phase has ended.\n");

    /* Start prediction */
    AdcSingleCycleScanModeTest();

    while(1);
}